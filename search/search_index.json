{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Concepts","text":"<p>Microservices</p>"},{"location":"Microservices/","title":"Microservices","text":"<ul> <li>Defining a microservices architecture </li> <li>Interprocess Communication</li> </ul>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/","title":"Defining a microservices architecture","text":""},{"location":"Microservices/Defining%20a%20microservices%20architecture/#approach-1-three-step-process","title":"Approach 1 - Three step process","text":"<p>According to [[Microservices Patterns]], its a three step process:</p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#step-1-identify-system-operations","title":"Step 1 - Identify System Operations","text":"<p>Starting point are the requirements like user stories. Instead of describing the requirements in terms of communication technologies like REST or messages, use more abstract notions like operations. A system operation is an abstraction of a request, that application must handle. It is either a command or a query. Use operations to understand business scenerios that illustrate how different components in a monolith collaborate. </p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#how","title":"How?","text":"<ul> <li>Create a high level domain model from requirements consisting of key components that provide a vocabulary to describe system operation.</li> <li>Identify system operations in terms of commands and queries and describe each one's behaviour in terms of domain model.  Its also a good point to think about preconditions and post conditions of the operations.</li> </ul>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#step-2-identify-services","title":"Step 2 - Identify Services","text":"<p>Decompose the monolith into functionally independent services. A service can represent a business capability or can represent a subdomain in the terms of domain driven design. The end result should be set of services which are organised around business concepts rather than technical concepts.</p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#how_1","title":"How?","text":"<p>Decompose by subdomain and Decompose by business capability are the two main patterns for defining an application\u2019s microservice architecture.</p> <ul> <li>Decompose by business capability - each business capability or collection of related business capabilities can thought as a business oriented service rather than technical. It defines clear contracts and SLAs. </li> <li>Decompose by sub domain - Capture knowledge about a domain and use that to solve problems within that domain. Domain defines the vocabulary used by the team.Domain driven design solves the problem by defining separate domain for each sub domain in application problem space. Sub domain are identified in a similar way as business capabilities.  The scope of the sub domain is called as a bounded context which is represented by a service. </li> </ul>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#step-3-identify-apis","title":"Step 3 - Identify APIs","text":"<p>Assign each service operations identified in the first step to a particular service. A service can fulfil the operation itself or can collaborate with other services to accomplish the same. In that case, also determine how services collaborate and determine additional supporting operation needed for the same. A service publishes events primarily to enable it to collaborate with other services.</p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#how_2","title":"How?","text":"<ul> <li>Map service operations to corresponding services</li> <li>Determine the apis required to support collaboration.</li> </ul> <p>Note: So far we have identified service and operations in an abstract manner. Operations can be sync or async in nature. Refer to Interprocess Communication to more detials on communciation standards.</p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#decomposition-guidelines","title":"Decomposition Guidelines","text":"<p>There are, some useful guidelines for decomposition that have their roots in object-oriented design. Let\u2019s take a look at them.</p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#single-responsibility-principle","title":"Single Responsibility Principle","text":"<p><code>_A class should have only one reason to change._</code></p> <p>We can apply SRP when defining microservice architecture and create small, cohesive services with single responsibility. This will reduce the size of the service and increase stability. </p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#common-closure-principle","title":"Common Closure Principle","text":"<p><code>_The classes in a package should be closed together against the same kinds of changes. A change that affects a package affects all the classes in that package._</code></p> <p>We can apply CCP when creating microservice architecture and package components that change for same reason in same service. </p>"},{"location":"Microservices/Defining%20a%20microservices%20architecture/#challenges-of-decomposition","title":"Challenges of decomposition","text":"<p>There could be challenges in defining microservices: 1. Network latency - too many round trips between services. 2. Sync Communication - can reduce the availability of overall user story. 3. Consistency - need to use patterns like [[Saga]] to maintain consistency of operations. 4. God Code - common code used throughout the application.</p>"}]}